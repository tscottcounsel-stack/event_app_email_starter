from __future__ import annotations
from typing import Any, Dict, Optional
from fastapi import APIRouter, HTTPException, status
from jose import jwt, JWTError
from pydantic import BaseModel, EmailStr
import os
from datetime import datetime, timedelta, timezone
from passlib.context import CryptContext

# ---- minimal settings (env overrides allowed) ----
SECRET_KEY = os.getenv("SECRET_KEY", "dev-secret-change-me")
ALGORITHM = os.getenv("ALGORITHM", "HS256")
ACCESS_MIN = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", "60"))
REFRESH_MIN = int(os.getenv("REFRESH_TOKEN_EXPIRE_MINUTES", str(60*24*7)))

pwd = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(p: str) -> str:
    return pwd.hash(p)

def verify_password(p: str, stored: str) -> bool:
    try:
        return pwd.verify(p, stored)
    except Exception:
        return p == (stored or "")

def create_token(claims: Dict[str, Any], minutes: int) -> str:
    data = claims.copy()
    data["exp"] = datetime.now(timezone.utc) + timedelta(minutes=minutes)
    return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)

# ---- schemas (kept local to avoid import mismatches) ----
class UserCreate(BaseModel):
    email: EmailStr
    password: str
    role: str = "vendor"

class LoginRequest(BaseModel):
    email: EmailStr
    password: str

class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"

class TokenRefreshRequest(BaseModel):
    refresh_token: str

# ---- in-memory repo ----
_mem: Dict[str, Dict[str, Any]] = {}
_seq = 0

def get_user(email: str) -> Optional[Dict[str, Any]]:
    return _mem.get(email)

def create_user(email: str, role: str, password_hash: str) -> Dict[str, Any]:
    global _seq
    _seq += 1
    u = {"id": _seq, "email": email, "role": role, "password_hash": password_hash}
    _mem[email] = u
    return u

# ---- router ----
router = APIRouter(prefix="/auth2", tags=["auth2"])

@router.get("/_diag")
def diag():
    return {"repo": "memory", "users": list(_mem.keys()), "alg": ALGORITHM, "access_min": ACCESS_MIN, "refresh_min": REFRESH_MIN}

@router.post("/register")
def register(payload: UserCreate):
    u = get_user(payload.email)
    if u:
        return {"id": u["id"], "email": u["email"], "role": u["role"]}
    u = create_user(payload.email, payload.role, hash_password(payload.password))
    return {"id": u["id"], "email": u["email"], "role": u["role"]}

@router.post("/login", response_model=Token)
def login(body: LoginRequest):
    u = get_user(body.email)
    if not u:
        u = create_user(body.email, "vendor", hash_password(body.password))
    stored = u.get("password_hash") or u.get("password") or ""
    if not verify_password(body.password, stored):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")
    access = create_token({"sub": str(u["id"]), "type": "access"}, ACCESS_MIN)
    refresh = create_token({"sub": str(u["id"]), "type": "refresh"}, REFRESH_MIN)
    return Token(access_token=access, refresh_token=refresh)

@router.post("/refresh", response_model=Token)
def refresh(body: TokenRefreshRequest):
    try:
        payload = jwt.decode(body.refresh_token, SECRET_KEY, algorithms=[ALGORITHM])
        if payload.get("type") != "refresh" or not payload.get("sub"):
            raise HTTPException(status_code=401, detail="Invalid refresh token")
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid refresh token")
    new_access = create_token({"sub": str(payload["sub"]), "type": "access"}, ACCESS_MIN)
    return Token(access_token=new_access, refresh_token=body.refresh_token)
